## Docker

### Docker是什么

#### 演化历史

硬件，操作系统和应用程序之间的关系：
```
+--------------------------+
|       Applications       |
+--------------------------+
|+------------------------+|
||    Runtime Library     ||
|+------------------------+|
||         Kernel         ||
|+------------------------+|
|     Operating System     |
+-----+--------+-----------+
| CPU | Memory | IO Device |
+-----+--------+-----------+
```

1. 随着硬件的发展，很多时候电脑的硬件性能其实是过剩的，即使无法完全满足峰值性能需求，但是大多数的时间是会有很大一部分资源是闲置的；
2. 不同的软件在同一个操作系统下面会有冲突；

为了解决不同的软件在同一个操作系统下面冲突的问题，只能配置多台计算机，或者在同一个计算机上面装多个操作系统，前者会导致性能的浪费，而后者切换起来非常麻烦。

由于硬件性能的提升，未来解决上述的问题，充分利用硬件的资源，所以出现了硬件虚拟化的概念。也就是通过软件仿真出计算机的硬件，这样就可以在这些虚拟出的硬件上面安装操作系统，即来宾操作系统。然后再在来宾操作系统上安装不同的软件。虚拟化的软件负责将软件对硬件的需求转发到真实的硬件中，如VMWare。

这类软件有一个专有名词Hypervisor，也就是Virtual Machine Monitor(VMM)。

根据访问硬件资源方式的不同，可以分为两类：
```
+-----+-----+-----+-----+
                             |App A|App B|App C|App D|
+-----+-----+-----+-----+    +-----+-----+-----+-----+
|App A|App B|App C|App D|    |Guest|Guest|Guest|Guest|
+-----+-----+-----+-----+    | OS0 | OS1 | OS2 | OS3 |
|Guest|Guest|Guest|Guest|    +-----+-----+-----+-----+
| OS0 | OS1 | OS2 | OS3 |    |        Hypervisor     |
+-----+-----+-----+-----+    +-----------------------+
|        Hypervisor     |    |         Host OS       |
+-----------------------+    +-----------------------+
|        Hardware       |    |        Hardware       |
+-----------------------+    +-----------------------+
          Type I                       Type II
```
一类是直接访问硬件资源，这种情况下，所有的虚拟机实际上是和当前操作系统所在的物理机是平级的，如Hyper-V，Xen；
另一类和普通的应用一样，运行在操作系统上，通过Host OS来访问硬件资源；
理论上，前者少了一层，性能会更好一点；

由于硬件虚拟化需要消耗大量的资源，因为不同的虚拟机之间资源是不共享的；而且大多数时候Guest Host类型实际上都是一样的，完全可以复用，只是运行库和应用不一样；所以为了复用操作系统，隔离运行库和应用，出现了操作系统虚拟化，也就是容器的概念。

物理机，容器和第二类虚拟机之间的区别：
```
+-----+-----+-----+-----+                                   +-----+-----+-----+-----+
|App A|App B|App C|App D|     +-----+-----+-----+-----+     |App A|App B|App C|App D|
+-----+-----+-----+-----+     |App A|App B|App C|App D|     +-----+-----+-----+-----+
|+---------------------+|     +-----+-----+-----+-----+     |Guest|Guest|Guest|Guest|
||   Runtime Library   ||     |Lib A|Lib B|Lib C|Lib D|     | OS0 | OS1 | OS2 | OS3 |
|+---------------------+|     +-----+-----+-----+-----+     +-----+-----+-----+-----+
||       Kernel        ||     |    Container Engine   |     |        Hypervisor     |
|+---------------------+|     +-----------------------+     +-----------------------+
|   Operating System    |     |         Host OS       |     |         Host OS       |
+-----------------------+     +-----------------------+     +-----------------------+
|       Hardware        |     |        Hardware       |     |        Hardware       |
+-----------------------+     +-----------------------+     +-----------------------+
    Physical Machine                  Container                 Type II Hypervisor
```

每个App和Lib结合，就是一个容器，也就是Docker里面的一个集装箱；
和虚拟机相比：
1. 迅速启动，因为没有虚拟机硬件的初始化，也不需要启动操作系统，也就是所谓的开箱即用；
2. 占用资源少，没有Guest OS占用更多的内存资源，也不需要提前预分配运行内存，也不需要提前安装运行App不需要的Lib；

但是由于共用内核，只靠cgroups进行隔离，所以不同应用之间的隔离是没有虚拟机那么彻底的，如果某个应用运行时导致内核崩溃，那么所有容器都会崩溃；而如果某个虚拟机里面的应用崩溃了，实际上是不会影响到其他虚拟机里面的应用的，除非虚拟机的Hypervisor有问题，或者是影响到了硬件；

Docker把App和Lib文件打包成一个镜像，采用类似多次快照的存储技术，如aufs/device mapper/btrs/zfs等，实现：
1. 多个App可以共用相同的底层镜像（初始的操作系统镜像）；
2. App运行时的IO操作和镜像文件隔离；
3. 通过挂载包含不同配置/数据文件的目录或者卷（Volume），单个App镜像可以同时用来运行无数个不同业务的容器；
```
+---------+  +---------+  +---------+    +-----+ +-----+ +-----+
| abc.com |  | def.com |  | xyz.com |    | DB1 | | DB2 | | DB3 |    
+----+----+  +----+----+  +----+----+    +--+--+ +--+--+ +--+--+    
     |            |            |            |       |       |
+----+----+  +----+----+  +----+----+    +--+--+ +--+--+ +--+--+    
|   abc   |  | def.com |  | xyz.com |    | DB1 | | DB2 | | DB3 |
| config  |  | config  |  | config  |    | conf| | conf| | conf|
|  data   |  |  data   |  |  data   |    | data| | data| | data|
+----+----+  +----+----+  +----+----+    +--+--+ +--+--+ +--+--+
     |            |            |            |       |       |
     +------------+------------+            +-------+-------+
                  |                                 |
           +------+------+                   +------+------+          
           | Nginx Image |                   | MySQL Image |
           +------+------+                   +------+------+
                  |                                 |
                  +----------------+----------------+
                                   |
                            +------+-------+ 
                            | Alpine Image |
                            +------+-------+
```

而且Docker提供公共的镜像仓库，Github Connect自动构建镜像，大大简化了应用分发、部署、升级的流程，而且Docker可以非常方便的建立各种自定义镜像文件；

所以绝大部分应用，开发者都可以通过docker build创建镜像，通过docker push上传镜像，用户通过docekr pull下载镜像，用docker run运行镜像。用户不需要关系如何搭建环境，如何安装，如何解决不同发行版的库冲突，而且通常不会消耗更多的硬件资源，不会明显降低性能，也就是所谓的标准化、集装箱；

除了docker以外，还有很多其他的容器；
windows由于使用微内核，而且内核和各种运行库耦合紧密，虽然从windows10开始也支持容器，但实际上还是通过Hyper-V运行不同的虚拟机进行内核级隔离，虽然也有线程级隔离，但是只有Windows Server支持，而且只能运行相同版本的镜像；即使是Hyper-V也支持运行更低版本的镜像而不能运行更高版本的镜像，而且Windows容器的镜像体积通常还是很大；

